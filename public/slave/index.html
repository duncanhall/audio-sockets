<html>
	<head>
	<script src="/socket.io/socket.io.js"></script>
	<script>

	var socket = null;
    var ClientCommand = {};

    var HAND_SHAKE = '<%= settings.CMD_HAND_SHAKE %>';
    var START = '<%= settings.CMD_START %>';
    var STOP = '<%= settings.CMD_STOP %>';
    var CHANGE = '<%= settings.CMD_CHANGE %>';
    var DISCONNECT = '<%= settings.CMD_DISCONNECT %>';

    var callibrationPoints = [];
    var boundary = {};

	function onload()
	{
		socket = io.connect('<%= settings.connectionURL %>');

		socket.on("connect", function() {
			socket.emit("id", "slave");
		});

		socket.on("cmd-client", function(data) {

			var id = data.id;
			var cmd = data.cmd;

			switch(cmd)
			{

				case HAND_SHAKE:
                    //Connection
					break;

				case START:
                    callibrationPoints.push(data.orientation);

                    if (callibrationPoints.length === 4) {
                        setPoints();
                    }

					break;

				case STOP:

					break;					

				case CHANGE:
                    var x = clamp(data.x, boundary.minX, boundary.maxX);
                    var y = clamp(data.y, boundary.minY, boundary.maxY);

                    var dx = (x - boundary.minX) / (boundary.maxX - boundary.minX);
                    var dy = (y - boundary.minY) / (boundary.maxY - boundary.minY);

                    y1 = (1 - dx) * window.innerHeight;
                    x1 = dy * window.innerWidth;
					break;

				case DISCONNECT:

					break;
			}
		});

        var clamp = function(num, min, max) {
            return num < min ? min : (num > max ? max : num);
        };

        function setPoints () {

            var minX = Number.MAX_VALUE;
            var minY = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var maxY = Number.MIN_VALUE;

            callibrationPoints.forEach(function (orientation) {
                minX = orientation.x < minX ? orientation.x : minX;
                minY = orientation.y < minY ? orientation.y : minY;
                maxX = orientation.x > maxX ? orientation.x : maxX;
                maxY = orientation.y > maxY ? orientation.y : maxY;
            });

            boundary.minX = minX;
            boundary.maxX = maxX;
            boundary.minY = minY;
            boundary.maxY = maxY;
        }


        var width = window.innerWidth;
        var height = window.innerHeight;
        var x1 = width / 2;
        var y1 = height / 2;
        var x0 = x1;
        var y0 = y1;
        var i = 0;
        var r = 140;
        var τ = 2 * Math.PI;

        var canvas = d3.select("body").append("canvas").attr("width", width).attr("height", height);
        var context = canvas.node().getContext("2d");
        context.globalCompositeOperation = "lighter";
        context.lineWidth = 0.3;

        d3.timer(function() {
            context.clearRect(0, 0, width, height);

            var z = d3.hsl(++i % 360, 1, 0.5).rgb();
            var c = "rgba(" + z.r + "," + z.g + "," + z.b + ",";
            var x = x0 += (x1 - x0) * 0.01;
            var y = y0 += (y1 - y0) * 0.01;

            d3.select({}).transition()
                .duration(3000)
                .ease(Math.sqrt)
                .tween("circle", function() {
                    return function(t) {
                        var q = 0.5;
                        var a = t < q ? q - (q - t) : 1 - t;
                        context.strokeStyle = c + a + ")";
                        context.beginPath();
                        context.arc(x, y, r * t, 0, τ);
                        context.stroke();
                    };
                });
        });

	}

	</script>
	<style>
        body, html {
            background-color: #111111;
            padding: 10px;
        }
	</style>
	</head>
	<body onload="onload();">
        <script src="http://d3js.org/d3.v3.min.js"></script>
	</body>
</html>
